- [[logseq]] 双端同步 简介
  collapsed:: true
	- logseq自带的，最高600秒自动push，每秒进行pull。
	- 插件中的Git，只能每秒自动push，自动pull没试出来。不过可以在header上手动控制git。
	- [CharlesChiuGit/Logseq-Git-Sync-101: This repo aims to help Logseq users to sync their data with Git and GitHub.](https://github.com/CharlesChiuGit/Logseq-Git-Sync-101)
		- 这里有windows和pc的相关设置。
		- 安卓用了[[termux]]来进行[[git]]管理，用 [[tasekr]]来自动化。
- [[chromium]]在 `\AppData\Local\Microsoft\Edge Dev\User Data\Default` 和 `Edge Dev\User Data\Profile 3` 之间替换文件实现不同用户配置快速修改。
  collapsed:: true
	- 不行，收藏夹依然会重置。算了不弄了。
- 不要用 [[logseq]]excalidraw ，可以用 Sketchbook、![]draw.io 做替代，把 Sketchbook 或draw.io的文件插到块里截个图就行。
- 昨天写的 [[Sublime Text 3]]的[[python]]代码今天报错：# NameError: global name 'uuid4()' is not defined (while it is defined.)
  collapsed:: true
	- 改了一下代码：
		- ```java
		  import sublime
		  import sublime_plugin
		  import os
		  import uuid
		  from datetime import datetime
		  from tempfile import gettempdir
		  
		  #plan
		      #通过日期创建文件夹
		  
		  
		  #监听器，监听新标签页，并设置名称和路径。
		  class TemporaryFileEventListener(sublime_plugin.EventListener):
		      #print("服务开始-》标签监听器启动")
		      def on_new(self, view):
		          #print("<<<<<<<<<<<")
		          #print("检测到新窗口，初始化名称")
		  
		          #调用方法，获取目标保存位置。
		          tmp_dir = get_temp_dir(view)
		          #print("设定的tmp_dir是:{}".format(tmp_dir))
		  
		          #如果工作区没有目标目录，则啥也不干。
		          #因为我指定固定目录，所以这里注释掉。
		          #if tmp_dir is None:
		          #    return
		  
		          #获取设置的后缀，默认是.txt
		          ext = view.settings().get("auto_save_buffer.default_extension", ".txt")
		  
		          now = datetime.now().strftime("%Y-%m-%d_%H%M%S")
		  
		          #print("生成的now是:{}".format(now))
		          #rnd = str(uuid4())[:8]
		          #NameError: global name 'uuid4()' is not defined (while it is defined.)
		          
		          #print("生成的rnd是:{}".format(rnd))
		          #tmp_name = "{}-{}{}".format(now, rnd, ext)
		          tmp_name = "{}-{}".format(now, ext)
		          #print("设定的tmp_name是:{}".format(tmp_name))
		  
		  
		          #print(">>>>>>>>>>>")
		  
		          #给每个新标签页 设置属性.
		          view.settings().set("_tmp_dir", tmp_dir)
		          view.settings().set("_tmp_name", tmp_name)
		          view.settings().set("default_dir", tmp_dir)
		          #设置标签名
		          view.set_name(tmp_name)
		  
		      def on_save(self, view):
		          #print("保存时，去除名字？")
		          view.settings().erase("_tmp_dir")
		          view.settings().erase("_tmp_name")
		  
		  
		  #这个命令通过快捷键/命令/等调用。运行run方法。
		  class SaveTemporaryBuffersCommand(sublime_plugin.WindowCommand):
		      """
		      当执行该命令时，该命令在当前窗口中寻找所有具有指定临时名称的文件强制将它们保存指定文件夹中，并使用该名称。
		      """
		      def run(self):
		          #print("保存启动")
		  
		          for view in self.window.views():
		              #print("保存开始")
		  
		              tmp_name = view.settings().get("_tmp_name")
		              #print("tmp_name是:{}".format(tmp_name))
		              
		              #没名字，肯定左栏没文件夹。
		              if tmp_name is not None:
		                  tmp_dir = view.settings().get("_tmp_dir")
		                  #print("tmp_dir是:{}".format(tmp_dir))
		                  
		                  #合并路径和名称->文件绝对路径。
		                  filename = os.path.join(str(tmp_dir), str(tmp_name))
		  
		                  #若文件不存在，同时名称未改动。则保存。retarget什么意思？
		                  if not os.path.exists(filename) and view.name() == tmp_name:
		                      view.retarget(filename)
		                      view.run_command("save")
		                      print("保存成功")
		              #还是不要删除这个变量了吧。有时候会先删除本地文件，而缓存还在。这样就不容易再保存，或者关闭了。
		              #不知道，这个变量不删掉，有没有啥不好？
		              #view.settings().erase("_tmp_name")
		              #view.settings().erase("_tmp_dir")
		  
		  
		  
		  def get_temp_dir(view):
		      #这里我个人直接返回目标目录，下面代码流程我不需要。   
		      return "f:/Users/birdy.OMEN/OneDrive/文档/backuphours/sublime"
		  
		      #TODO START
		          #若左工作栏有临时目录，或配置文件中设置的目录的父级目录，则返回目录。
		          #若没有，则返回NONE。
		      #END
		  
		      #给定一个view（新临时标签页）
		      #配置文件中设置的子位置，获取临时标签页的临时位置，返回的是个list
		      dirs = view.settings().get("auto_save_buffer.locations", [gettempdir()])
		      #print("配置文件中的dirs是:{}".format(dirs))
		  
		  
		      # 获取窗口中可用的文件夹 位置 ，该列表可能为无
		      window = view.window() or sublime.active_window()
		      folders = window.folders() or []
		      #print("侧栏存在的文件夹folder是 {}".format(folder))
		  
		      # 迭代左栏中，文件夹
		      for folder in folders:
		          #检测有没有符合咱设置的目录的。如果有，就优先返回左侧栏的文件夹。
		          if folder in dirs:
		              #print("dirs")
		              return folder
		  
		  #   return None
		  
		  ```
- [[logseq]]用 [[chatgpt]]插件来总结每日日记。
	- 其实不行，有时有代码，内容太长。
- [[Nobelium]] 这个[[博客]]添加了目录，这个博客很干净，很喜欢。当然了和 [[notionnext]]两个可以一起用。
	- 遇到的问题：
		- vercle 在一段时间内，持续构建错误，警告页面过大，错误信息是接口超时，我觉得是 Notion 那边的问题（响应太慢）。你的页~~面涉及大量~~ Database 数据也有一定影响。你可以过会儿再试试。
		- [[Nobelium/特性]]
			- ```java
			  东发
			  ```
		- [[Nobelium/bug]]
			- 标签页 移动浮框
			-
- 尝试在 [[Notion]]里embed [[logseq]]这个发布页，但是不行。看了下响应头里面并没有 `x-frame-options: sameorigin`之类的东西。不清楚为啥，去提了个issues。
	- 我以为
	  collapsed:: true
		- ~~我用vercle部署了Nobelium和logseq。Nobelium是可以embed进Notin，而logseq却不行。~~
		  ~~说明和部署平台无关~~
		- [nobelium blog](https://blog.fpb.icu)
		  [logseq blog ](https://fpb.icu)
		- [ignore -x-frame-chromium plus](https://chrome.google.com/webstore/detail/ignore-x-frame-headers/gleekbfjekiniecknbkamfmkohkpodhe)
		- 装完插件可以来[这里](https://blog.fpb.icu/embed-logseq-3W8e1nhGu9h9t6)看效果
		- 当用插件去除x-frame-options: sameorigin之类的东西时，logseq才可以在网页版notion中出现。
		  而我在指向logseq域名的请求中，并未看到x-frame-options: sameorigin之类的东西，所以不清楚发生了什么，故临此请教。
		  ![clipboard_20230401_000001](https://user-images.githubusercontent.com/128216091/229171418-aeab0725-cc7a-49f6-8df5-edf441dcc6a8.png)
	- 测试
		- Notion客户端无法embed logseqweb
		- edge无插件Notion可以embedlogseqweb
		- 问题似乎不在logseqweb
		- 而在Notion客户端。可是Notion客户端除了目标网站禁止iframe才不显示外，难道自己也会有限制？
			- 自己的限制一种是云请求的黑名单限制，就是限制你不能embed，但实际上能embed的网址，比如p*b。
				- 但这种显示是可以通过二次跳转进入的。等于是逃过了notion的云检查。
					- 错了，Notion修复了二次跳转!p*b跳转不过去了。。
			-
- [[Nobelium]]和 [[logseq]]publish的区别
	-